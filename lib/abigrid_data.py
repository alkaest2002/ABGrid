"""
Filename: abgrid_data.py
Description: Manages and processes data related to AB-Grid networks.

Author: Pierpaolo Calanna
Date Created: May 3, 2025

The code is part of the AB-Grid project and is licensed under the MIT License.
"""

import re
import datetime

from pathlib import Path
from typing import Any, List, Tuple, Dict, Optional
from lib.abgrid_sna import ABGridSna
from lib.abgrid_sociogram import ABGridSociogram

class ABGridData:
    """
    Class for managing and processing project data related to AB-Grid networks.
    """

    def __init__(
        self, project: str, 
        project_folderpath: Path, 
        project_filepath: Path, 
        groups_filepaths: list[Path], 
        data_loader: Any
    ):
        """
        Initialize the ABGridData object with project and group data paths.

        Args:
            project (str): The name of the project.
            project_folderpath (Path): Path to the project folder.
            project_filepath (Path): Path to the the project's main configuration file.
            groups_filepaths (list[Path]): List of paths to group-specific data files.
            data_loader (Any): Data loading utility for reading and validating YAML configuration files.
        """
        self.project = project
        self.project_folderpath = project_folderpath
        self.project_filepath = project_filepath
        self.data_loader = data_loader
        try:
            sorted_filepaths = sorted(groups_filepaths, key=lambda x: int(re.search(r'\d+$', x.stem).group()))
        except:
            sorted_filepaths = sorted(groups_filepaths)
        self.groups_filepaths = sorted_filepaths

    def pydantic_errors_messages(self, errors: List[Dict[str, Any]]) -> str:
        """
        Format Pydantic validation error messages into a readable string.

        This method takes a list of errors, typically generated by Pydantic validation,
        and formats each error message into a string. Each message is prefixed by "-->"
        and all messages are joined with newline characters for readability.

        Args:
            errors (List[Dict[str, Any]]): A list of dictionaries, where each dictionary
                represents an error with at least a 'msg' key that contains the error message.

        Returns:
            str: A string with each error message formatted and joined by newlines.
        """
        return "\n".join([f"--> {e['msg']}" for e in errors])


    def get_project_data(self) -> Tuple[Optional[Dict[str, Any]], Optional[Any]]:
        """
        Load and prepare data for generating answer sheets.

        Returns:
            Tuple[Optional[Dict[str, Any]], Optional[Any]]: 
                - If answersheet data is successfully loaded, a tuple containing the answersheet data and None for errors.
                - If loading fails, a tuple containing None for the answersheet data and the errors encountered.
        """
        # Load project data
        project_data, validation_errors = self.data_loader.load_data("project", self.project_filepath)

        # If project data was correctly loaded
        if project_data is not None:
            
            # Return project data with no errors
            return project_data, None
        
        else:
            # Return no project data with errors
            return None, self.pydantic_errors_messages(validation_errors)

    def get_group_data(self, group_filepath: Path) -> Tuple[Optional[Dict[str, Any]], Optional[Any]]:
        """
        Load and validate group data from the specified file path.

        Args:
            group_filepath (Path): A Path object representing the file path to the group data file.

        Returns:
            Tuple[Optional[Dict[str, Any]], Optional[Any]]: 
                - If group data is successfully loaded, a tuple containing the group data and None for errors.
                - If loading fails, a tuple containing None for the group data and the errors encountered.
        """

        # Load group data
        group_data, validation_errors = self.data_loader.load_data("group", group_filepath)

         # If group data was correctly loaded
        if group_data is not None:

            # Return group data with no errors
            return group_data, None
        
        else:
            # Return no group data with errors
            return None, self.pydantic_errors_messages(validation_errors)
        
    def get_report_data(self, group_filepath: Path, with_sociogram: bool = False) -> Tuple[Optional[Dict[str, Any]], Optional[Any]]:
        """
        Load and prepare data for generating a group's report.

        Args:
            group_filepath (Path): Path to the group-specific data file.
            with_sociogram (bool): A flag indicating whether to include sociograms in the reports.

        Returns:
           Tuple[Optional[Dict[str, Any]], Optional[Any]]: 
                - If report data is successfully loaded, a tuple containing the report data and None for errors.
                - If loading fails, a tuple containing None for the report data and the errors encountered.
        """
        # Load project data
        project_data, project_validation_errors = self.data_loader.load_data("project", self.project_filepath)
        
        # If project data was correctly loaded
        if project_data is not None:
            
            # Load group data
            group_data, group_validation_errors = self.data_loader.load_data("group", group_filepath)
            
            # If group data was correctly loaded
            if group_data is not None:
                
                # Init sna
                abgrid_sna = ABGridSna()

                # Compute sna data
                sna = abgrid_sna.get(group_data["choices_a"], group_data["choices_b"])
                
                # Prepare report data
                report_data = {
                    "project_title": project_data["project_title"],
                    "year": datetime.datetime.now(datetime.UTC).year,
                    "group": int(re.search(r'(\d+)$', group_filepath.stem).group(0)),
                    "members_per_group": len(group_data["choices_a"]),
                    "question_a": project_data["question_a"],
                    "question_b": project_data["question_b"],
                    "sna": {
                        "edges_a": sna["edges_a"],
                        "edges_b": sna["edges_b"],
                        "macro_stats_a": sna["macro_stats_a"],
                        "macro_stats_b": sna["macro_stats_b"],
                        "micro_stats_a": sna["micro_stats_a"].to_dict('index'),
                        "micro_stats_b": sna["micro_stats_b"].to_dict('index'),
                        "rankings_a": sna["rankings_a"],
                        "rankings_b": sna["rankings_b"],
                        "edges_types_a": sna["edges_types_a"],
                        "edges_types_b": sna["edges_types_b"],
                        "components_a":sna["components_a"],
                        "components_b":sna["components_b"],
                        "graph_a": sna["graph_a"],
                        "graph_b": sna["graph_b"],
                    },
                }

                # Add sociogram data to report data, if requested
                if with_sociogram:

                    # Init sociogram class
                    abgrid_sociogram = ABGridSociogram()

                    # Compute sociogram
                    sociogram = abgrid_sociogram.get(sna)
                
                    report_data["sociogram"] = {
                            "micro_stats": sociogram["micro_stats"].to_dict("index"),
                            "macro_stats": sociogram["macro_stats"].to_dict("index"),
                            "graph_ic": sociogram["graph_ic"],
                            "graph_ac": sociogram["graph_ac"],
                            "rankings": sociogram["rankings"],
                            "supplemental": sociogram["supplemental"]
                        }
                
                # Return report data with no errors
                return report_data, None
            else:
                # Return no report data with group errors
                return None, self.pydantic_errors_messages(group_validation_errors)
        else:
            # Return no report data with project errors
            return None, self.pydantic_errors_messages(project_validation_errors)
