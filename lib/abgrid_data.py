"""
Filename: abgrid_data.py
Description: Manages and processes data related to AB-Grid networks.

Author: Pierpaolo Calanna
Date Created: May 3, 2025

The code is part of the AB-Grid project and is licensed under the MIT License.
"""

import re
import datetime

from pathlib import Path
from typing import Any, List, Tuple, Dict, Optional
from lib.abgrid_sna import ABGridSna
from lib.abgrid_sociogram import ABGridSociogram

class ABGridData:
    """
    Class for managing and processing project data related to AB-Grid networks.
    """
    
    def __init__(
        self, 
        project: str, 
        project_folderpath: Path, 
        project_filepath: Path, 
        groups_filepaths: List[Path], 
        data_loader: Any
    ):
        """
        Initialize the ABGridData object with project and group data paths.

        Args:
            project (str): The name of the project.
            project_folderpath (Path): The path to the project folder.
            project_filepath (Path): The path to the project's main configuration file.
            groups_filepaths (List[Path]): A list of paths to group-specific data files.
            data_loader (Any): A data loading utility for reading and validating YAML configuration files.
        """
        self.project = project
        self.project_folderpath = project_folderpath
        self.project_filepath = project_filepath
        self.data_loader = data_loader
        
        # Attempt to sort group file paths numerically based on the trailing digits in filenames
        try:
            sorted_filepaths = sorted(groups_filepaths, key=lambda x: int(re.search(r'\d+$', x.stem).group()))
        except Exception:
            sorted_filepaths = sorted(groups_filepaths)

        self.groups_filepaths = sorted_filepaths

    def pydantic_errors_messages(self, errors: List[Dict[str, Any]]) -> str:
        """
        Format Pydantic validation error messages into a readable string.

        This method takes a list of errors, typically generated by Pydantic validation,
        and formats each error message into a readable string. Each message is prefixed 
        by "-->" and all messages are joined with newline characters.

        Args:
            errors (List[Dict[str, Any]]): A list of dictionaries, where each dictionary
                represents an error with at least a 'msg' key that contains the error message.

        Returns:
            str: A string with each error message formatted and joined by newlines.
        """
        return "\n".join([f"--> {e['msg']}" for e in errors])

    def get_project_data(self) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
        """
        Load and return project configuration data.

        Returns:
            Tuple[Optional[Dict[str, Any]], Optional[str]]: 
                - If project data is successfully loaded, a tuple containing the project data and None for errors.
                - If loading fails, a tuple containing None for project data and a string with formatted error messages.
        """
        # Load project data
        project_data, validation_errors = self.data_loader.load_data("project", self.project_filepath)

        # Return based on success or failure
        if project_data is not None:
            return project_data, None
        else:
            return None, self.pydantic_errors_messages(validation_errors)

    def get_group_data(self, group_filepath: Path) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
        """
        Load and validate group data from the specified file path.

        Args:
            group_filepath (Path): A Path object representing the file path to the group data file.

        Returns:
            Tuple[Optional[Dict[str, Any]], Optional[str]]: 
                - If group data is successfully loaded, a tuple containing the group data and None for errors.
                - If loading fails, a tuple containing None for group data and a string with formatted error messages.
        """
        # Load group data
        group_data, validation_errors = self.data_loader.load_data("group", group_filepath)

        # Return based on success or failure
        if group_data is not None:
            return group_data, None
        else:
            return None, self.pydantic_errors_messages(validation_errors)
        
    def get_report_data(self, group_filepath: Path, with_sociogram: bool = False) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
        """
        Load and prepare data for generating a group's report.

        Args:
            group_filepath (Path): The path to the group-specific data file.
            with_sociogram (bool, optional): Flag indicating whether to include sociograms in the report. Default is False.

        Returns:
            Tuple[Optional[Dict[str, Any]], Optional[str]]: 
                - If report data is successfully loaded, a tuple containing the report data and None for errors.
                - If loading fails, a tuple containing None for the report data and a string with formatted error messages.
        """
        # Load project data
        project_data, project_validation_errors = self.data_loader.load_data("project", self.project_filepath)

        if project_data is not None:
            # Load group data
            group_data, group_validation_errors = self.data_loader.load_data("group", group_filepath)
            
            if group_data is not None:
                # Initialize SNA utility
                abgrid_sna = ABGridSna()

                # Compute SNA data
                sna = abgrid_sna.get(group_data["choices_a"], group_data["choices_b"])
                
                # Prepare the report data
                report_data = {
                    "project_title": project_data["project_title"],
                    "year": datetime.datetime.now(datetime.UTC).year,
                    "group": int(re.search(r'(\d+)$', group_filepath.stem).group(0)),
                    "members_per_group": len(group_data["choices_a"]),
                    "question_a": project_data["question_a"],
                    "question_b": project_data["question_b"],
                    "sna": sna,
                }

                if with_sociogram:
                    # Initialize Sociogram utility
                    abgrid_sociogram = ABGridSociogram()

                    # Compute and add sociogram data
                    sociogram = abgrid_sociogram.get(sna)
                    report_data["sociogram"] = sociogram
                
                return report_data, None
            else:
                return None, self.pydantic_errors_messages(group_validation_errors)
        else:
            return None, self.pydantic_errors_messages(project_validation_errors)
        